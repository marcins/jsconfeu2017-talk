<HTML>
<HEAD>
<TITLE>
</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<A HREF="contents.htm">[Contents]</A> <A HREF="corea2.htm">[Previous]</A> <A HREF="doc.htm">[Next]</A> <A HREF="refix.htm">[Index]</A>
<HR>

<A NAME="RegExp"></A>
<A NAME="1158210">
<H1> RegExp</H1>
</A>
<A NAME="1158211">
A regular expression object contains the pattern of a regular expression. It has properties and methods for using that regular expression to find and replace matches in strings. <P></A>
<A NAME="1139875">
In addition to the properties of an individual regular expression object that you create using the <CODE>RegExp</CODE> constructor function, the predefined <CODE>RegExp</CODE> object has static properties that are set whenever any regular expression is used.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1139716">
<I>Core object</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1139720">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1139722">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1150835">
<H4> Created by</H4>
</A>

<A NAME="1150836">
A literal text format or the <CODE>RegExp</CODE> constructor function. <P></A>
<A NAME="1151066">
The literal format is used as follows:<P></A>
<A NAME="1150970">
<PRE>/<I>pattern</I>/<I>flags</I></PRE></A><A NAME="1151072">
The constructor function is used as follows:<P></A>
<A NAME="1150972">
<PRE>new RegExp("<I>pattern</I>", "<I>flags</I>")</PRE></A>
<A NAME="Head3;"></A>
<A NAME="1150973">
<H4> Parameters</H4>
</A>

<A NAME="1151256">
<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151135">
<PRE>pattern</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151137">
The text of the regular expression.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151139">
<PRE>flags</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151141">
(Optional) If specified, flags can have one of the following 3 values:</A></P><ul><A NAME="1151142">
<LI><CODE>g</CODE>: global match</A><A NAME="1151143">
<LI><CODE>i</CODE>: ignore case</A><A NAME="1151144">
<LI><CODE>gi</CODE>: both global match and ignore case</A></ul>

</TABLE>
<P></A>
<A NAME="1151373">
Notice that the parameters to the literal format do not use quotation marks to indicate strings, while the parameters to the constructor function do use quotation marks. So the following expressions create the same regular expression:<P></A>
<A NAME="1151390">
<PRE>/ab+c/i<br>new RegExp("ab+c", "i")</PRE></A>
<A NAME="Head3;"></A>
<A NAME="1139666">
<H4> Description</H4>
</A>

<A NAME="1151498">
When using the constructor function, the normal string escape rules (preceding special characters with \ when included in a string) are necessary. For example, the following are equivalent:<P></A>
<A NAME="1151509">
<PRE>re = new&nbsp;RegExp("\\w+")<br>re = /\w+/</PRE></A><A NAME="1151535">
<A HREF="corea3.htm#1151535">Table&nbsp;4.3</A> provides a complete list and description of the special characters that can be used in regular expressions. <P><B><A NAME="1151542">
Table 4.3&nbsp;Special characters in regular expressions. &nbsp;</A></B>
<TABLE BORDER="0">
<TR><TH VALIGN=baseline ALIGN=left><B><A NAME="1151546">
<B>Character
</B></A></B><TH VALIGN=baseline ALIGN=left><B><A NAME="1151548">
<B>Meaning
</B></A></B>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151550">
<PRE>\</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151552">
For characters that are usually treated literally, indicates that the next character is special and not to be interpreted literally. </A></P><A NAME="1151553">
For example, <CODE>/b/</CODE> matches the character 'b'. By placing a backslash in front of b, that is by using <CODE>/\b/</CODE>, the character becomes special to mean match a word boundary.</A></P><A NAME="1151554">
-or-</A></P><A NAME="1151555">
For characters that are usually treated specially, indicates that the next character is not special and should be interpreted literally. </A></P><A NAME="1151556">
For example, <CODE>*</CODE> is a special character that means 0 or more occurrences of the preceding character should be matched; for example, <CODE>/a*/</CODE> means match 0 or more a's<CODE>.</CODE> To match <CODE>*</CODE> literally, precede the it with a backslash; for example, <CODE>/a\*/</CODE> matches 'a*'.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151558">
<PRE>^</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151560">
Matches beginning of input or line.</A></P><A NAME="1151561">
For example, <CODE>/^A/</CODE> does not match the 'A' in "an A," but does match it in "An A."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151563">
<PRE>$</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151565">
Matches end of input or line.</A></P><A NAME="1151566">
For example, <CODE>/t$/</CODE> does not match the 't' in "eater", but does match it in "eat"</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151568">
<PRE>*</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151570">
Matches the preceding character 0 or more times.</A></P><A NAME="1151571">
For example, <CODE>/bo*/</CODE> matches 'boooo' in "A ghost booooed" and 'b' in "A bird warbled", but nothing in "A goat grunted".</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151573">
<PRE>+</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151575">
Matches the preceding character 1 or more times. Equivalent to <CODE>{1,}</CODE>.</A></P><A NAME="1151576">
For example, <CODE>/a+/</CODE> matches the 'a' in "candy" and all the a's in "caaaaaaandy."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151578">
<PRE>?</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151580">
Matches the preceding character 0 or 1 time.</A></P><A NAME="1151581">
For example, <CODE>/e?le?/</CODE> matches the 'el' in "angel" and the 'le' in "angle."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151583">
<PRE>.</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151585">
(The decimal point) matches any single character except the newline character.</A></P><A NAME="1151586">
For example, <CODE>/.n/</CODE> matches 'an' and 'on' in "nay, an apple is on the tree", but not 'nay'.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151588">
<PRE>(x)</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151590">
Matches 'x' and remembers the match.</A></P><A NAME="1151591">
For example, <CODE>/(foo)/</CODE> matches and remembers 'foo' in "foo bar." The matched substring can be recalled from the resulting array's elements <CODE>[1]</CODE>, ..., <CODE>[n]</CODE>, or from the predefined <CODE>RegExp</CODE> object's properties <CODE>$1</CODE><I>, ..., </I><CODE>$9</CODE>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151593">
<PRE>x|y</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151595">
Matches either 'x' or 'y'.</A></P><A NAME="1151596">
For example, <CODE>/green|red/</CODE> matches 'green' in "green apple" and 'red' in "red apple."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151598">
<PRE>{n}</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151600">
Where <CODE>n</CODE> is a positive integer. Matches exactly <CODE>n</CODE> occurrences of the preceding character.</A></P><A NAME="1151601">
For example, <CODE>/a{2}/</CODE> doesn't match the 'a' in "candy," but it matches all of the a's in "caandy," and the first two a's in "caaandy."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151603">
<PRE>{n,}</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151605">
Where <CODE>n</CODE> is a positive integer. Matches at least <CODE>n</CODE> occurrences of the preceding character.</A></P><A NAME="1151606">
For example, <CODE>/a{2,}</CODE> doesn't match the 'a' in "candy", but matches all of the a's in "caandy" and in "caaaaaaandy."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151608">
<PRE>{n,m}</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151610">
Where <CODE>n</CODE> and <CODE>m</CODE> are positive integers. Matches at least <CODE>n</CODE> and at most <CODE>m</CODE> occurrences of the preceding character.</A></P><A NAME="1151611">
For example, <CODE>/a{1,3}/</CODE> matches nothing in "cndy", the 'a' in "candy," the first two a's in "caandy," and the first three a's in "caaaaaaandy" Notice that when matching "caaaaaaandy", the match is "aaa", even though the original string had more a's in it.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151613">
<PRE>[xyz]</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151615">
A character set. Matches any one of the enclosed characters. You can specify a range of characters by using a hyphen.</A></P><A NAME="1151616">
For example, <CODE>[abcd]</CODE> is the same as <CODE>[a-c]</CODE>. They match the 'b' in "brisket" and the 'c' in "ache"<CODE>.</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151618">
<PRE>[^xyz]</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151620">
A negated or complemented character set. That is, it matches anything that is not enclosed in the brackets. You can specify a range of characters by using a hyphen.</A></P><A NAME="1151621">
For example, <CODE>[^abc]</CODE> is the same as <CODE>[^a-c]</CODE>. They initially match 'r' in "brisket" and 'h' in "chop."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151623">
<PRE>[\b]</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151625">
Matches a backspace. (Not to be confused with <CODE>\b</CODE>.)</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151627">
<PRE>\b</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151629">
Matches a word boundary, such as a space. (Not to be confused with <CODE>[\b]</CODE>.)</A></P><A NAME="1151630">
For example, <CODE>/\bn\w/</CODE> matches the 'no' in "noonday";<CODE>/\wy\b/</CODE> matches the 'ly' in "possibly yesterday."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151632">
<PRE>\B</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151634">
Matches a non-word boundary.</A></P><A NAME="1151635">
For example, <CODE>/\w\Bn/</CODE> matches 'on' in "noonday", and <CODE>/y\B\w/</CODE> matches 'ye' in "possibly yesterday."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151637">
<PRE>\c<I>X</I></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151639">
Where <I>X</I> is a control character. Matches a control character in a string.</A></P><A NAME="1151640">
For example, <CODE>/\cM/</CODE> matches control-M in a string.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151642">
<PRE>\d</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151644">
Matches a digit character. Equivalent to <CODE>[0-9]</CODE>.</A></P><A NAME="1151645">
For example, <CODE>/\d/</CODE> or <CODE>/[0-9]/</CODE> matches '2' in "B2 is the suite number."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151647">
<PRE>\D</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151649">
Matches any non-digit character. Equivalent to <CODE>[^0-9]</CODE>.</A></P><A NAME="1151650">
For example, <CODE>/\D/</CODE> or <CODE>/[^0-9]/</CODE> matches 'B' in "B2 is the suite number."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151652">
<PRE>\f</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151654">
Matches a form-feed.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151656">
<PRE>\n</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151658">
Matches a linefeed.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151660">
<PRE>\r</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151662">
Matches a carriage return.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151664">
<PRE>\s</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151666">
Matches a single white space character, including space, tab, form feed, line feed. Equivalent to <CODE>[ \f\n\r\t\v]</CODE>.</A></P><A NAME="1151667">
for example, <CODE>/\s\w*/</CODE> matches ' bar' in "foo bar."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151669">
<PRE>\S</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151671">
Matches a single character other than white space. Equivalent to <CODE>[^ \f\n\r\t\v]</CODE>.</A></P><A NAME="1151672">
For example, <CODE>/\S/\w*</CODE> matches 'foo' in "foo bar."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151674">
<PRE>\t</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151676">
Matches a tab</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151678">
<PRE>\v</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151680">
Matches a vertical tab.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151682">
<PRE>\w</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151684">
Matches any alphanumeric character including the underscore. Equivalent to <CODE>[A-Za-z0-9_]</CODE>.</A></P><A NAME="1151685">
For example, <CODE>/\w/</CODE> matches 'a' in "apple," '5' in "$5.28," and '3' in "3D."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151687">
<PRE>\W </PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151689">
Matches any non-word character. Equivalent to <CODE>[^A-Za-z0-9_]</CODE>.</A></P><A NAME="1151690">
For example, <CODE>/\W/</CODE> or <CODE>/[^$A-Za-z0-9_]/</CODE> matches '%' in "50%."</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151692">
<PRE>\<I>n</I></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151694">
Where <I>n</I> is a positive integer. A back reference to the last substring matching the <I>n</I> parenthetical in the regular expression (counting left parentheses).</A></P><A NAME="1151695">
For example, <CODE>/apple(,)\sorange\1/</CODE> matches 'apple, orange', in "apple, orange, cherry, peach." A more complete example follows this table.</A></P><A NAME="1151696">
<B>Note:</B> If the number of left parentheses is less than the number specified in \<I>n</I>, the \<I>n</I> is taken as an octal escape as described in the next row.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1151698">
<PRE>\o<I>octal<br></I>\x<I>hex</I></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1151700">
Where <CODE>\o</CODE><I><CODE>octal</CODE></I> is an octal escape value or <CODE>\x</CODE><I><CODE>hex</CODE></I> is a hexadecimal escape value. Allows you to embed ASCII codes into regular expressions.</A></P>

</TABLE>
<P></A>
<A NAME="1151530">
The literal notation provides compilation of the regular expression when the expression is evaluated. Use literal notation when the regular expression will remain constant. For example, if you use literal notation to construct a regular expression used in a loop, the regular expression won't be recompiled on each iteration. <P></A>
<A NAME="1151449">
The constructor of the regular expression<B> </B>object, for example, <CODE>new&nbsp;RegExp("ab+c")</CODE>, provides runtime compilation of the regular expression. Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input. Once you have a defined regular expression, and if the regular expression is used throughout the script and may change, you can use the <A HREF="corea3.htm#1141078"><CODE>compile</CODE></A> method to compile a new regular expression for efficient reuse. <P></A>
<A NAME="1139667">
A separate predefined <CODE>RegExp</CODE> object is available in each window; that is, each separate thread of JavaScript execution gets its own <CODE>RegExp</CODE> object. Because each script runs to completion without interruption in a thread, this assures that different scripts do not overwrite values of the <CODE>RegExp</CODE> object.<P></A>
<A NAME="1139668">
The predefined <CODE>RegExp</CODE> object contains the static properties <A HREF="corea3.htm#1140126"><CODE>input</CODE></A>, <A HREF="corea3.htm#1153377"><CODE>multiline</CODE></A>, <A HREF="corea3.htm#1140242"><CODE>lastMatch</CODE></A>, <A HREF="corea3.htm#1140246"><CODE>lastParen</CODE></A>, <A HREF="corea3.htm#1140250"><CODE>leftContext</CODE></A>, <A HREF="corea3.htm#1140254"><CODE>rightContext</CODE></A>, and <CODE>$1</CODE> through <CODE>$9</CODE>. The <A HREF="corea3.htm#1140126"><CODE>input</CODE></A> and <A HREF="corea3.htm#1153377"><CODE>multiline</CODE></A> properties can be preset. The values for the other static properties are set after execution of the <A HREF="corea3.htm#1141105"><CODE>exec</CODE></A> and <A HREF="corea3.htm#1141269"><CODE>test</CODE></A> methods of an individual regular expression object, and after execution of the <A HREF="corea2.htm#1026931"><CODE>match</CODE></A> and <A HREF="corea2.htm#1027809"><CODE>replace</CODE></A> methods of <A HREF="corea2.htm#1012977"><CODE>String</CODE></A>. <P></A>

<A NAME="Head3;"></A>
<A NAME="1140908">
<H4> Property Summary</H4>
</A>

<A NAME="1139472">
Note that several of the <CODE>RegExp</CODE> properties have both long and short (Perl-like) names. Both names always refer to the same value. Perl is the programming language from which JavaScript modeled its regular expressions. <P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153712">
<PRE><A HREF="corea3.htm#1153548"><CODE>$1, ..., $9</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153714">
Parenthesized substring matches, if any.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153719">
<PRE><A HREF="corea3.htm#1153578"><CODE>$_</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153724">
See <A HREF="corea3.htm#1140126"><CODE>input</CODE></A>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153729">
<PRE><A HREF="corea3.htm#1153584"><CODE>$*</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153734">
See <A HREF="corea3.htm#1153377"><CODE>multiline</CODE></A>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153739">
<PRE><A HREF="corea3.htm#1153590"><CODE>$&amp;</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153744">
See <A HREF="corea3.htm#1140242"><CODE>lastMatch</CODE></A>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153749">
<PRE><A HREF="corea3.htm#1153596"><CODE>$+</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153754">
See <A HREF="corea3.htm#1140246"><CODE>lastParen</CODE></A>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153759">
<PRE><A HREF="corea3.htm#1153602"><CODE>$`</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153764">
See <A HREF="corea3.htm#1140250"><CODE>leftContext</CODE></A>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153769">
<PRE><A HREF="corea3.htm#1153608"><CODE>$'</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153774">
See <A HREF="corea3.htm#1140254"><CODE>rightContext</CODE></A>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141421">
<PRE><A HREF="corea3.htm#1141034"><CODE>global</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141423">
Whether or not to test the regular expression against all possible matches in a string, or only against the first.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141428">
<PRE><A HREF="corea3.htm#1141037"><CODE>ignoreCase</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141430">
Whether or not to ignore case while attempting a match in a string.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1139475">
<PRE><A HREF="corea3.htm#1140126"><CODE>input</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1139477">
The string against which a regular expression is matched.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141452">
<PRE><A HREF="corea3.htm#1153261"><CODE>lastIndex</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141454">
The index at which to start the next match. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1139483">
<PRE><A HREF="corea3.htm#1140242"><CODE>lastMatch</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1139485">
The last matched characters.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1139487">
<PRE><A HREF="corea3.htm#1140246"><CODE>lastParen</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1139489">
The last parenthesized substring match, if any.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1139491">
<PRE><A HREF="corea3.htm#1140250"><CODE>leftContext</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1139493">
The substring preceding the most recent match.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141471">
<PRE><A HREF="corea3.htm#1153377"><CODE>multiline</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141473">
Whether or not to search in strings across multiple lines.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1139495">
<PRE><A HREF="corea3.htm#1140254"><CODE>rightContext</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1139497">
The substring following the most recent match.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141490">
<PRE><A HREF="corea3.htm#1153097"><CODE>source</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141492">
The text of the pattern.</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1139606">
<H4> Method Summary</H4>
</A>

<A NAME="1141021">
<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141004">
<PRE><A HREF="corea3.htm#1141078"><CODE>compile</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141006">
Compiles a regular expression object.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141011">
<PRE><A HREF="corea3.htm#1141105"><CODE>exec</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141013">
Executes a search for a match in its string parameter. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141018">
<PRE><A HREF="corea3.htm#1141269"><CODE>test</CODE></A></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141020">
Tests for a match in its string parameter. </A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141350">
<H4> Examples</H4>
</A>

<A NAME="1141352">
<B>Example 1.</B> The following script uses the <CODE>replace</CODE> method to switch the words in the string. For the replacement text, the script uses the values of the <CODE>$1</CODE> and <CODE>$2</CODE><I> </I>properties of the global <CODE>RegExp</CODE> object. Note that the <CODE>RegExp</CODE> object name is not be prepended to the <CODE>$</CODE> properties when they are passed as the second argument to the <CODE>replace</CODE> method. <P></A>
<A NAME="1141354">
<PRE>&lt;SCRIPT LANGUAGE="JavaScript1.2"&gt;<br>re = /(\w+)\s(\w+)/;<br>str = "John Smith";<br>newstr=str.replace(re, "$2, $1");<br>document.write(newstr)<br>&lt;/SCRIPT&gt;</PRE></A><A NAME="1141355">
This displays "Smith, John". <P></A>
<A NAME="1141357">
<B>Example 2.</B> In the following example, <CODE>RegExp.input</CODE> is set by the Change event. In the <CODE>getInfo</CODE> function, the <CODE>exec</CODE> method uses the value of <CODE>RegExp.input</CODE> as its argument. Note that <CODE>RegExp</CODE> is prepended to the <CODE>$</CODE> properties. <P></A>
<A NAME="1141359">
<PRE>&lt;HTML&gt;</PRE></A><A NAME="1141360">
<PRE>&lt;SCRIPT LANGUAGE="JavaScript1.2"&gt;<br>function getInfo() {<br>&nbsp;&nbsp;&nbsp;re = /(\w+)\s(\d+)/;<br>&nbsp;&nbsp;&nbsp;re.exec();<br>&nbsp;&nbsp;&nbsp;window.alert(RegExp.$1 + ", your age is " + RegExp.$2);<br>}<br>&lt;/SCRIPT&gt;</PRE></A><A NAME="1141361">
<PRE>Enter your first name and your age, and then press Enter.</PRE></A><A NAME="1141362">
<PRE>&lt;FORM&gt;<br>&lt;INPUT TYPE:"TEXT" NAME="NameAge" onChange="getInfo(this);"&gt;<br>&lt;/FORM&gt;</PRE></A><A NAME="1141363">
<PRE>&lt;/HTML&gt;</PRE></A>
<A NAME="Head2;"></A>
<A NAME="1139506">
<H3> Properties</H3>
</A>


<A NAME="Head2Ref;"></A>
<A NAME="1153548">
<H2>$1, ..., $9</H2>
</A>

<A NAME="1153565">
Properties that contain parenthesized substring matches, if any. <P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153551">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1153556">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1153558">
<I>Static, Read-only</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153562">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1153564">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1153566">
<H4> Description</H4>
</A>

<A NAME="1153567">
Because <CODE>input</CODE> is static, it is not a property of an individual regular expression object. Instead, you always use it as <CODE>RegExp.input</CODE>.<P></A>
<A NAME="1153568">
The number of possible parenthesized substrings is unlimited, but the predefined <CODE>RegExp</CODE> object can only hold the last nine. You can access all parenthesized substrings through the returned array's indexes.<P></A>
<A NAME="1153572">
These properties can be used in the replacement text for the <A HREF="corea2.htm#1027809"><CODE>String.replace</CODE></A> method. When used this way, do not prepend them with <CODE>RegExp</CODE>. The example below illustrates this. When parentheses are not included in the regular expression, the script interprets <I><CODE>$n</CODE></I>'s literally (where <I><CODE>n</CODE></I> is a positive integer).<P></A>

<A NAME="Head3;"></A>
<A NAME="1153573">
<H4> Examples</H4>
</A>

<A NAME="1153574">
The following script uses the <CODE>replace</CODE> method to switch the words in the string. For the replacement text, the script uses the values of the <CODE>$1</CODE> and <CODE>$2</CODE><I> </I>properties of the global <CODE>RegExp</CODE> object. Note that the <CODE>RegExp</CODE> object name is not be prepended to the <CODE>$</CODE> properties when they are passed as the second argument to the <CODE>replace</CODE> method. <P></A>
<A NAME="1153575">
<PRE>&lt;SCRIPT LANGUAGE="JavaScript1.2"&gt;<br>re = /(\w+)\s(\w+)/;<br>str = "John Smith";<br>newstr=str.replace(re, "$2, $1");<br>document.write(newstr)<br>&lt;/SCRIPT&gt;</PRE></A><A NAME="1153576">
This displays "Smith, John". <P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153578">
<H2>$_</H2>
</A>

<A NAME="1153582">
See <A HREF="corea3.htm#1140126"><CODE>input</CODE></A>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153584">
<H2>$*</H2>
</A>

<A NAME="1153588">
See <A HREF="corea3.htm#1153377"><CODE>multiline</CODE></A>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153590">
<H2>$&amp;</H2>
</A>

<A NAME="1153594">
See <A HREF="corea3.htm#1140242"><CODE>lastMatch</CODE></A>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153596">
<H2>$+</H2>
</A>

<A NAME="1153600">
See <A HREF="corea3.htm#1140246"><CODE>lastParen</CODE></A>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153602">
<H2>$`</H2>
</A>

<A NAME="1153606">
See <A HREF="corea3.htm#1140250"><CODE>leftContext</CODE></A>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153608">
<H2>$'</H2>
</A>

<A NAME="1153612">
See <A HREF="corea3.htm#1140254"><CODE>rightContext</CODE></A>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1141034">
<H2>global</H2>
</A>

<A NAME="1141035">
Whether or not the <CODE>"g"</CODE> flag is used with the regular expression. <P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141500">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141505">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1141791">
<I>Read-only</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141511">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141513">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141765">
<H4> Description</H4>
</A>

<A NAME="1141769">
<CODE>global</CODE> is a property of an individual regular expression object.<P></A>
<A NAME="1149915">
The value of <CODE>global</CODE> is <CODE>true</CODE> if the <CODE>"g"</CODE> flag was used; otherwise, <CODE>false</CODE>. The <CODE>"g"</CODE> flag indicates that the regular expression should be tested against all possible matches in a string. <P></A>
<A NAME="1141848">
You cannot change this property directly. However, calling the <A HREF="corea3.htm#1141078"><CODE>compile</CODE></A> method changes the value of this property.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1141037">
<H2>ignoreCase</H2>
</A>

<A NAME="1141038">
Whether or not the <CODE>"i"</CODE> flag is used with the regular expression. <P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141542">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141547">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1141807">
<I>Read-only</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141549">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141551">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141780">
<H4> Description</H4>
</A>

<A NAME="1149931">
<CODE>ignoreCase</CODE> is a property of an individual regular expression object.<P></A>
<A NAME="1141784">
The value of <CODE>ignoreCase</CODE> is <CODE>true</CODE> if the <CODE>"i"</CODE> flag was used; otherwise, <CODE>false</CODE>. The <CODE>"i"</CODE> flag indicates that case should be ignored while attempting a match in a string.<P></A>
<A NAME="1141873">
You cannot change this property directly. However, calling the <A HREF="corea3.htm#1141078"><CODE>compile</CODE></A> method changes the value of this property.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1140126">
<H2>input</H2>
</A>

<A NAME="1140145">
The string against which a regular expression is matched. <CODE>$_</CODE> is another name for the same property. <P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140112">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140117">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1140119">
<I>Static</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140123">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140125">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1140156">
<H4> Description</H4>
</A>

<A NAME="1140161">
Because <CODE>input</CODE> is static, it is not a property of an individual regular expression object. Instead, you always use it as <CODE>RegExp.input</CODE>.<P></A>
<A NAME="1149990">
If no string argument is provided to a regular expression's <CODE>exec</CODE> or <CODE>test</CODE> methods, and if <CODE>RegExp.input</CODE> has a value, its value is used as the argument to that method.<P></A>
<A NAME="1140201">
The script or the browser can preset the <CODE>input</CODE> property. If preset and if no string argument is explicitly provided, the value of <CODE>input</CODE> is used as the string argument to the <CODE>exec</CODE> or <CODE>test</CODE> methods of the regular expression object. <CODE>input</CODE> is set by the browser in the following cases: <P></A>
<ul><P>
<A NAME="1140202">
<LI>When an event handler is called for a <CODE>TEXT</CODE> form element, <CODE>input</CODE> is set to the value of the contained text. </LI>
</A><P>
<A NAME="1140203">
<LI>When an event handler is called for a <CODE>TEXTAREA</CODE> form element, <CODE>input</CODE> is set to the value of the contained text. Note that <CODE>multiline</CODE> is also set to <CODE>true</CODE> so that the match can be executed over the multiple lines of text. </LI>
</A><P>
<A NAME="1140204">
<LI>When an event handler is called for a <CODE>SELECT</CODE> form element, <CODE>input</CODE> is set to the value of the selected text. </LI>
</A><P>
<A NAME="1140205">
<LI>When an event handler is called for a <CODE>Link</CODE> object, <CODE>input</CODE> is set to the value of the text between <CODE>&lt;A HREF=...&gt;</CODE> and <CODE>&lt;/A&gt;</CODE>. </LI>
</A></ul><A NAME="1140206">
The value of the <CODE>input</CODE> property is cleared after the event handler completes.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153261">
<H2>lastIndex</H2>
</A>

<A NAME="1153262">
A read/write integer property that specifies the index at which to start the next match. <P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153265">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1153270">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153272">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1153274">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1153275">
<H4> Description</H4>
</A>

<A NAME="1153276">
<CODE>lastIndex</CODE> is a property of an individual regular expression object.<P></A>
<A NAME="1153277">
This property is set only if the regular expression used the <CODE>"g"</CODE> flag to indicate a global search. The following rules apply: <P></A>
<ul><P>
<A NAME="1153278">
<LI>If <CODE>lastIndex</CODE> is greater than the length of the string, <CODE>regexp.test</CODE> and <CODE>regexp.exec</CODE> fail, and <CODE>lastIndex</CODE> is set to <CODE>0</CODE>.</LI>
</A><P>
<A NAME="1153279">
<LI>If <CODE>lastIndex</CODE> is equal to the length of the string and if the regular expression matches the empty string, then the regular expression matches input starting at <CODE>lastIndex</CODE><I>.</I> </LI>
</A><P>
<A NAME="1153280">
<LI>If <CODE>lastIndex</CODE> is equal to the length of the string and if the regular expression does not match the empty string, then the regular expression mismatches input, and <CODE>lastIndex</CODE> is reset to 0. </LI>
</A><P>
<A NAME="1153281">
<LI>Otherwise, <CODE>lastIndex</CODE> is set to the next position following the most recent match. </LI>
</A></ul><A NAME="1153295">
For example, consider the following sequence of statements: <P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153284">
<PRE>re = /(hi)?/g</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153286">
Matches the empty string.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153288">
<PRE>re("hi")</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153290">
Returns <CODE>["hi", "hi"]</CODE> with <CODE>lastIndex</CODE> equal to <CODE>2</CODE>.</A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153292">
<PRE>re("hi")</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1153294">
Returns <CODE>[""]</CODE>, an empty array whose zeroth element is the match string. In this case, the empty string because <CODE>lastIndex</CODE> was 2 (and still is 2) and <CODE>"hi"</CODE> has length 2.</A></P>

</TABLE>
<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1140242">
<H2>lastMatch</H2>
</A>

<A NAME="1140244">
The last matched characters. <CODE>$&amp;</CODE> is another name for the same property.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140343">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140348">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1140350">
<I>Static, Read-only</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140354">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140356">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1150087">
<H4> Description</H4>
</A>

<A NAME="1150026">
Because <CODE>lastMatch</CODE> is static, it is not a property of an individual regular expression object. Instead, you always use it as <CODE>RegExp.lastMatch</CODE>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1140246">
<H2>lastParen</H2>
</A>

<A NAME="1140248">
The last parenthesized substring match, if any. <CODE>$+</CODE> is another name for the same property.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140364">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140369">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1140371">
<I>Static, Read-only</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140375">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140377">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1150095">
<H4> Description</H4>
</A>

<A NAME="1150096">
Because <CODE>lastParen</CODE> is static, it is not a property of an individual regular expression object. Instead, you always use it as <CODE>RegExp.lastParen</CODE>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1140250">
<H2>leftContext</H2>
</A>

<A NAME="1140252">
The substring preceding the most recent match. <CODE>$` </CODE>is another name for the same property.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140391">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140396">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1140398">
<I>Static, Read-only</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140402">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140404">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1150091">
<H4> Description</H4>
</A>

<A NAME="1150028">
Because <CODE>leftContext</CODE> is static, it is not a property of an individual regular expression object. Instead, you always use it as <CODE>RegExp.leftContext</CODE>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153377">
<H2>multiline</H2>
</A>

<A NAME="1153378">
Reflects whether or not to search in strings across multiple lines. $* is another name for the same property.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153381">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1153386">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1153388">
<I>Static</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153392">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1153394">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1153395">
<H4> Description</H4>
</A>

<A NAME="1153396">
Because <CODE>multiline</CODE> is static, it is not a property of an individual regular expression object. Instead, you always use it as <CODE>RegExp.multiline</CODE>.<P></A>
<A NAME="1153397">
The value of <CODE>multiline</CODE> is <CODE>true</CODE> if multiple lines are searched, <CODE>false</CODE> if searches must stop at line breaks. <P></A>
<A NAME="1153398">
The script or the browser can preset the <CODE>multiline</CODE> property. When an event handler is called for a <CODE>TEXTAREA</CODE> form element, the browser sets <CODE>multiline</CODE> to <CODE>true</CODE>. <CODE>multiline</CODE> is cleared after the event handler completes. This means that, if you've preset multiline to <CODE>true</CODE>, it is reset to <CODE>false</CODE> after the execution of any event handler. <P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1140254">
<H2>rightContext</H2>
</A>

<A NAME="1140256">
The substring following the most recent match. <CODE>$' </CODE>is another name for the same property.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140413">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140418">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1140420">
<I>Static, Read-only</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1140424">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1140426">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1150103">
<H4> Description</H4>
</A>

<A NAME="1150055">
Because <CODE>rightContext</CODE> is static, it is not a property of an individual regular expression object. Instead, you always use it as <CODE>RegExp.rightContext</CODE>.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1153097">
<H2>source</H2>
</A>

<A NAME="1153098">
A read-only property that contains the text of the pattern, excluding the forward slashes and <CODE>"g"</CODE> or <CODE>"i"</CODE> flags.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153101">
<I>Property of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1153106">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=2 ROWSPAN=1><A NAME="1153108">
<I>Read-only</I></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1153112">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1153114">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1153115">
<H4> Description</H4>
</A>

<A NAME="1153116">
<CODE>source</CODE> is a property of an individual regular expression object.<P></A>
<A NAME="1153120">
You cannot change this property directly. However, calling the <A HREF="corea3.htm#1141078"><CODE>compile</CODE></A> method changes the value of this property.<P></A>

<A NAME="Head2;"></A>
<A NAME="1140051">
<H3> Methods</H3>
</A>


<A NAME="Head2Ref;"></A>
<A NAME="1141078">
<H2>compile</H2>
</A>

<A NAME="1141079">
Compiles a regular expression object during execution of a script. <P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141621">
<I>Method of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141626">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141628">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141630">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141080">
<H4> Syntax</H4>
</A>

<A NAME="1141081">
<PRE>regexp.compile(pattern, flags)</PRE></A>
<A NAME="Head3;"></A>
<A NAME="1141082">
<H4> Parameters</H4>
</A>

<A NAME="1150562">
<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1150654">
<PRE>regexp</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1150658">
<CODE>The </CODE>name of the regular expression. It can be a variable name or a literal. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1150571">
<PRE>pattern</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1150611">
A string containing the text of the regular expression. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1150575">
<PRE>flags</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1150577">
(Optional) If specified, flags can have one of the following 3 values:</A></P><ul><A NAME="1150619">
<LI><CODE>"g"</CODE>: global match</A><A NAME="1150639">
<LI><CODE>"i"</CODE>: ignore case</A><A NAME="1150627">
<LI><CODE>"gi"</CODE>: both global match and ignore case</A></ul>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141100">
<H4> Description</H4>
</A>

<A NAME="1141101">
Use the <CODE>compile</CODE> method to compile a regular expression created with the <CODE>RegExp</CODE> constructor function. This forces compilation of the regular expression once only which means the regular expression isn't compiled each time it is encountered. Use the <CODE>compile</CODE> method when you know the regular expression will remain constant (after getting its pattern) and will be used repeatedly throughout the script. <P></A>
<A NAME="1141102">
You can also use the <CODE>compile</CODE> method to change the regular expression during execution. For example, if the regular expression changes, you can use the <CODE>compile</CODE> method to recompile the object for more efficient repeated use.<P></A>
<A NAME="1141735">
Calling this method changes the value of the regular expression's <A HREF="corea3.htm#1153097"><CODE>source</CODE></A>, <A HREF="corea3.htm#1141034"><CODE>global</CODE></A>, and <A HREF="corea3.htm#1141037"><CODE>ignoreCase</CODE></A> properties.<P></A>

<A NAME="Head2Ref;"></A>
<A NAME="1141105">
<H2>exec</H2>
</A>

<A NAME="1141106">
Executes the search for a match in a specified string. Returns a result array.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141655">
<I>Method of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141660">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141662">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141664">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141107">
<H4> Syntax</H4>
</A>

<A NAME="1141108">
<PRE>regexp.exec(str)<br>regexp(str)</PRE></A>
<A NAME="Head3;"></A>
<A NAME="1141111">
<H4> Parameters</H4>
</A>

<A NAME="1141112">
<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1150691">
<PRE>regexp</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1150693">
<CODE>The </CODE>name of the regular expression. It can be a variable name or a literal. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1150702">
<PRE>str</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1150720">
(Optional) The string against which to match the regular expression. If omitted, the value of <A HREF="corea3.htm#1140126"><CODE>RegExp.input</CODE></A> is used.</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141117">
<H4> Description</H4>
</A>

<A NAME="1141121">
As shown in the syntax description, a regular expression's <CODE>exec</CODE> method call be called either directly, (with <CODE>regexp.exec(str)</CODE>) or indirectly (with <CODE>regexp(str)</CODE>).<P></A>
<A NAME="1150765">
If you are executing a match simply to find <CODE>true</CODE> or <CODE>false</CODE>, use the <A HREF="corea3.htm#1141269"><CODE>test</CODE></A> method or the <CODE>String</CODE> <A HREF="corea2.htm#1030143"><CODE>search</CODE></A> method. <P></A>
<A NAME="1141125">
If the match succeeds, the <CODE>exec</CODE> method returns an array and updates properties of the regular expression object and the predefined regular expression object, <CODE>RegExp</CODE>. If the match fails, the <CODE>exec</CODE> method returns <CODE>null</CODE>. <P></A>
<A NAME="1141126">
Consider the following example: <P></A>
<A NAME="1141127">
<PRE>&lt;SCRIPT LANGUAGE="JavaScript1.2"&gt;<br>//Match one d followed by one or more b's followed by one d<br>//Remember matched b's and the following d<br>//Ignore case<br>myRe=/d(b+)(d)/ig;<br>myArray = myRe.exec("cdbBdbsbz");<br>&lt;/SCRIPT&gt;</PRE></A><A NAME="1141252">
The following table shows the results for this script: <P><B></B>
<TABLE BORDER="0">
<TR><TH VALIGN=baseline ALIGN=left><B><A NAME="1141130">
<B>Object
</B></A></B><TH VALIGN=baseline ALIGN=left><B><A NAME="1141132">
<B>Property/Index
</B></A></B><TH VALIGN=baseline ALIGN=left><B><A NAME="1141134">
<B>Description
</B></A></B><TH VALIGN=baseline ALIGN=left><B><A NAME="1141136">
<B>Example
</B></A></B>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=1 ROWSPAN=5><A NAME="1141138">
<PRE>myArray</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141140">
<PRE></PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141142">
The contents of <CODE>myArray</CODE></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141144">
<CODE>["dbBd", "bB", "d"]</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141148">
<PRE>index</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141150">
The 0-based index of the match in the string</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141152">
<CODE>1</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141156">
<PRE>input</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141158">
The original string</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141160">
<CODE>cdbBdbsbz</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141164">
<PRE>[0]</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141166">
The last matched characters</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141168">
<CODE>dbBd</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141172">
<PRE>[1], ...[n]</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141174">
The parenthesized substring matches, if any. The number of possible parenthesized substrings is unlimited.</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141176">
<CODE>[1] = bB<br>[2] = d</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=1 ROWSPAN=4><A NAME="1141178">
<PRE>myRe</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141180">
<PRE>lastIndex</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141182">
The index at which to start the next match.</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141184">
<CODE>5</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141188">
<PRE>ignoreCase</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141190">
Indicates if the <CODE>"i"</CODE> flag was used to ignore case</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141192">
<CODE>true</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141196">
<PRE>global</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141198">
Indicates if the <CODE>"g"</CODE> flag was used for a global match</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141200">
<CODE>true</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141204">
<PRE>source</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141206">
The text of the pattern</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141208">
<CODE>d(b+)(d)</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left COLSPAN=1 ROWSPAN=5><A NAME="1141210">
<PRE>RegExp</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141215">
<PRE>lastMatch<br>$&amp;</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141217">
The last matched characters</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141219">
<CODE>dbBd</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141223">
<PRE>leftContext<br>$\Q</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141225">
The substring preceding the most recent match</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141227">
<CODE>c</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141231">
<PRE>rightContext<br>$'</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141233">
The substring following the most recent match</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141235">
<CODE>bsbz</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141239">
<PRE>$1, ...$9</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141241">
The parenthesized substring matches, if any. The number of possible parenthesized substrings is unlimited, but <CODE>RegExp</CODE> can only hold the last nine.</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141243">
<CODE>$1 = bB&nbsp; <br>$2 = d</CODE></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141247">
<PRE>lastParen&nbsp; <br>$+</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1141249">
The last parenthesized substring match, if any.</A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141251">
<CODE>d</CODE></A></P>

</TABLE>
<P></A>
<A NAME="1141253">
If your regular expression uses the <CODE>"g"</CODE> flag, you can use the <CODE>exec</CODE> method multiple times to find successive matches in the same string. When you do so, the search starts at the substring of <CODE>str</CODE> specified by the regular expression's <CODE>lastIndex</CODE> property. For example, assume you have this script:<P></A>
<A NAME="1141254">
<PRE>&lt;SCRIPT LANGUAGE="JavaScript1.2"&gt;<br>myRe=/ab*/g;<br>str = "abbcdefabh"<br>myArray = myRe.exec(str);<br>document.writeln("Found " + myArray[0] + <br>&nbsp;&nbsp;&nbsp;". Next match starts at " + myRe.lastIndex)<br>mySecondArray = myRe.exec(str);<br>document.writeln("Found " + mySecondArray[0] + <br>&nbsp;&nbsp;&nbsp;". Next match starts at " + myRe.lastIndex)<br>&lt;/SCRIPT&gt;</PRE></A><A NAME="1141255">
This script displays the following text:<P></A>
<A NAME="1141256">
Found abb. Next match starts at 3<br>Found ab. Next match starts at 9<P></A>

<A NAME="Head3;"></A>
<A NAME="1141257">
<H4> Examples</H4>
</A>

<A NAME="1141258">
In the following example, the user enters a name and the script executes a match against the input. It then cycles through the array to see if other names match the user's name. <P></A>
<A NAME="1141259">
This script assumes that first names of registered party attendees are preloaded into the array A, perhaps by gathering them from a party database. <P></A>
<A NAME="1141260">
<PRE>&lt;HTML&gt;</PRE></A><A NAME="1141261">
<PRE>&lt;SCRIPT LANGUAGE="JavaScript1.2"&gt;<br>A = ["Frank", "Emily", "Jane", "Harry", "Nick", "Beth", "Rick", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Terrence", "Carol", "Ann", "Terry", "Frank", "Alice", "Rick", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Bill", "Tom", "Fiona", "Jane", "William", "Joan", "Beth"]</PRE></A><A NAME="1141262">
<PRE>function lookup() {<br>&nbsp;&nbsp;&nbsp;firstName = /\w+/i();<br>&nbsp;&nbsp;&nbsp;if (!firstName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.alert (RegExp.input + " isn't a name!");<br>&nbsp;&nbsp;&nbsp;else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i=0; i&lt;A.length; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (firstName[0].toLowerCase() == A[i].toLowerCase()) count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (count ==1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midstring = " other has ";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midstring = " others have ";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.alert ("Thanks, " + count + midstring + "the same name!")<br>&nbsp;&nbsp;&nbsp;}<br>}</PRE></A><A NAME="1141263">
<PRE>&lt;/SCRIPT&gt;</PRE></A><A NAME="1141264">
<PRE>Enter your first name and then press Enter.</PRE></A><A NAME="1141265">
<PRE>&lt;FORM&gt; &lt;INPUT TYPE:"TEXT" NAME="FirstName" onChange="lookup(this);"&gt; &lt;/FORM&gt;</PRE></A><A NAME="1141266">
<PRE>&lt;/HTML&gt;</PRE></A>
<A NAME="Head2Ref;"></A>
<A NAME="1141269">
<H2>test</H2>
</A>

<A NAME="1141270">
Executes the search for a match between a regular expression and a specified string. Returns <CODE>true</CODE> or <CODE>false</CODE>.<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141676">
<I>Method of</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141681">
<A HREF="corea3.htm#1158210"><CODE>RegExp</CODE></A></A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1141683">
<I>Implemented in</I></A></P><TD VALIGN=baseline ALIGN=left><A NAME="1141685">
Navigator 4.0, Netscape Server 3.0</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141271">
<H4> Syntax</H4>
</A>

<A NAME="1141272">
<PRE>regexp.test(str)</PRE></A>
<A NAME="Head3;"></A>
<A NAME="1141273">
<H4> Parameters</H4>
</A>

<A NAME="1141274">
<P><B></B>
<TABLE BORDER="0">
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1150810">
<PRE>regexp</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1150812">
<CODE>The </CODE>name of the regular expression. It can be a variable name or a literal. </A></P>
<TR><TD VALIGN=baseline ALIGN=left><A NAME="1150814">
<PRE>str</PRE></A><TD VALIGN=baseline ALIGN=left><A NAME="1150816">
(Optional) The string against which to match the regular expression. If omitted, the value of <A HREF="corea3.htm#1140126"><CODE>RegExp.input</CODE></A> is used.</A></P>

</TABLE>
<P></A>

<A NAME="Head3;"></A>
<A NAME="1141279">
<H4> Description</H4>
</A>

<A NAME="1141280">
When you want to know whether a pattern is found in a string use the <CODE>test</CODE> method (similar to the <A HREF="corea2.htm#1030143"><CODE>String.search</CODE></A> method); for more information (but slower execution) use the <A HREF="corea3.htm#1141105"><CODE>exec</CODE></A> method (similar to the <A HREF="corea2.htm#1026931"><CODE>String.match</CODE></A> method). <P></A>

<A NAME="Head3;"></A>
<A NAME="1141290">
<H4> Example</H4>
</A>

<A NAME="1141291">
The following example prints a message which depends on the success of the test:<P></A>
<A NAME="1141292">
<PRE>function testinput(re, str){<br>&nbsp;&nbsp;&nbsp;if (re.test(str))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midstring = " contains ";<br>&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;midstring = " does not contain ";<br>&nbsp;&nbsp;&nbsp;document.write (str + midstring + re.source);<br>}</PRE></A><A NAME="1165773">
<PRE></PRE></A><A NAME="1168473">
<P></A>

<P><HR>
<A HREF="contents.htm">[Contents]</A> <A HREF="corea2.htm">[Previous]</A> <A HREF="doc.htm">[Next]</A> <A HREF="refix.htm">[Index]</A>
<P ALIGN=right>

<FONT SIZE=-2><I>Last Updated:  10/31/97  12:30:31
</I></FONT>

<HR SIZE=4>

<P> <CENTER>Copyright  1997
<A HREF="http://home.netscape.com/misc/contact_info.html"
TARGET=_top>Netscape Communications Corporation</A></FONT>
</CENTER>
<P>
<P>
</BODY>
</HTML>

